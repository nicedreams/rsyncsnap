#!/bin/bash
# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ rsyncsnap -- Rsync Incremental Backups Using Bash                          ║
# ║ https://github.com/nicedreams/rsyncsnap                                    ║
# ║ ------------------------------------------------------------------------   ║
# ║ Copyright (C) 2020  Kenneth Bernier <kbernier@gmail.com>                   ║
# ║                                                                            ║
# ║ This program is free software: you can redistribute it and/or modify       ║
# ║ it under the terms of the GNU General Public License as published by       ║
# ║ the Free Software Foundation, either version 3 of the License, or          ║
# ║ (at your option) any later version.                                        ║
# ║                                                                            ║
# ║ This program is distributed in the hope that it will be useful,            ║
# ║ but WITHOUT ANY WARRANTY; without even the implied warranty of             ║
# ║ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the              ║
# ║ GNU General Public License for more details.                               ║
# ║                                                                            ║
# ║ You should have received a copy of the GNU General Public License          ║
# ║ along with this program.  If not, see <https://www.gnu.org/licenses/>.     ║
# ╚════════════════════════════════════════════════════════════════════════════╝

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ VARIABLES                                                                  ║
# ╚════════════════════════════════════════════════════════════════════════════╝
program_title="RSYNCSNAP"
## Add extra rsync options
## NOTICE: Do Not Use --delete Will cause consistency issues with incremental snapshots.
## NOTICE: Removing -r causes rsync not to transfer sub-directories even though -a is used for some reason.
rsync_options=(-arvhxSR)
#rsync_options=(-avhxRHAWXS)
## Add extra ssh options (Remove -q to have SSH verbose output.)
ssh_options=(-n -q)
## datetime formatting
datetime="$(printf '%(%Y-%m-%d_%H.%M.%S)T' -1)"
## Temp log location
log_tmp="/tmp/rsyncsnap.tmp"
## Source location removing trailing slash variable
source="${1%/}"
## Destination directory to store backups removing trailing slash from variable)
destination="${2%/}"
## Set variables if (ssh) colon detected in destination
if [[ "${destination}" = *:* ]]; then
  use_ssh="Y"
  ssh_server="${destination%:*}"
  destination_dir="${destination#*:}"
else
  destination_dir="${destination}"
fi
## Name the destination backup archive based on directory base or include filename
backup_base="${source[0]##*/}"
backup_base="${backup_base%.*}"
## Softlink name (add/remove . to beginning if want link hidden or visable in backup)
current_link="${backup_base}-current"
## Set empty variables
error_warn=""

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ FUNCTIONS                                                                  ║
# ╚════════════════════════════════════════════════════════════════════════════╝

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - msg/warn/err/succ log formatting                                ║
# ╚════════════════════════════════════════════════════════════════════════════╝
msg() {
   printf "%s[${program_title}] ${*}\n"
}

suc() {
  log_subject[0]="[COMPLETED]"
  log_subject[1]="(rsyncsnap)"
  log_subject[2]="${*}"
}

warn() {
  log_subject[0]="[WARNING]"
  log_subject[1]="(rsyncsnap)"
  log_subject[2]="${*}"
}

err() {
  log_subject[0]="[ERROR]"
  log_subject[1]="(rsyncsnap)"
  log_subject[2]="${*}"
  error_warn="Y"
  log_errors
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - usage                                                           ║
# ╚════════════════════════════════════════════════════════════════════════════╝
usage() {
echo "
-------------------------------------------------------------------------------
rsyncsnap

Uses rsync to create incremental hard link snapshots of directories.

https://github.com/nicedreams/rsyncsnap
-------------------------------------------------------------------------------
- Performs push backup from local to remote server by default.
- To perform pull backup from remote server to local use
  --pull and --sudo options.
--------------------------------------------------------------------------------
USAGE:

  rsyncsnap  <source>  <destination>  <options>

  # Using include file (rsyncsnap.include)
  rsyncsnap /root/rsyncsnap.include /mnt/backups \\
            --exclude /root/rsyncsnap.exclude \\
            --snap-amount 30 \\
            --snap-days 45 \\
            --logfile /var/log/rsyncsnap.log \\
            --mail user@domain \\
            --syslog

  # Using single source directory (/home/user)
  rsyncsnap /home/user /mnt/backups \\
            --snap-days 60 \\
            --mail user@domain

  # Using include file to SSH destination (user@server:/)
  rsyncsnap /root/rsyncsnap.include user@server:/home/user/backups \\
            --exclude /root/rsyncsnap.exclude \\
            --snap-amount 30 \\
            --logfile /var/log/rsyncsnap.log
            
  # Performing pull backup from remote server to local directory          
  rsyncsnap user@server /srv/backups/
            --pull \":/etc/ :/home/ :/usr/local/\" \\
            --sudo rsync \\
            --exclude /home/user/rsyncsnap.exclude \\
            --snap-amount 14 \\
            --logfile /var/log/rsyncsnap-pull.log

  <source>        Full path and filename of directory or rsyncsnap.include file
  <destination>   Where to store backups
  <options>       Listed below
--------------------------------------------------------------------------------
- Using single directory as source will backup single directory.
- Using include file as source will backup directories listed in file.
- Can use multiple source directories within \"quotes\"
  \"/home/user/ /etc/ /usr/local/bin/\"
--------------------------------------------------------------------------------
OPTIONS:

  --snap-amount | Amount of snapshots to keep.
                  --snap-amount 30                      (Keep 30 total snapshots)

  --snap-days     How many days to keep snapshots.
                  --snap-days 45                      (Keep 45 days of snapshots)
                  **Not recommended when using SSH for destination**

  --exclude |     Path of exclude file
                  --exclude /home/user/rsyncsnap.exclude
-------------------------------------
  --logfile       Create/Append log to single file

  --mail |        Send mail using mail command
  --email         --mail user@domain.com  OR  --mail root
                  
  --syslog        Send status to syslog using logger
-------------------------------------
  --rsync-options Default: ${rsync_options[*]}                                                                                                                                                                
                  Use custom rsync options instead of built-in default.
                  **Must Use \"quotes\"
                  --rsync-options \"-axHAWXS --progress\"

  --numeric-ids   Use --numeric-ids option when using rsync to use numeric
                  user/group rather than uid/gid
-------------------------------------
  --pull          Perform pull backup from remote server to local destination
                  --pull <remote directories>
                  --pull \":/etc/ :/home/ :/usr/local/\"

  --sudo          Use sudo on remote server to elevate permissions while rsync
                  --rsync-path=\"sudo user\"
-------------------------------------
  --ssh-options   Include options for SSH
                  --ssh-options \"-p 22 -i /home/user/.ssh/keyfile\"

  --ssh           Force using SSH as destination. Use if having issues.
-------------------------------------
  --dryrun        Perform rsync version backup using --dry-run to test backup.
                  No actual backup will be performed.
                  **Use without -logfile --syslog --email options.**

  --debug         Use set-x bash option when running script.

  -h | --help     Print this usage information.
--------------------------------------------------------------------------------
NAME OF BACKUP:
  - Name of backup is set using first part of include filename or the source
    directory name if doing single directory backup.
  - Can name include file and extension anything and extension is not required.
  - Recommend using rsyncsnap as filename when using includes file to keep track
    of how backup was performed.

SSH:
  - Use --ssh-options to add regular SSH arguments to command
    --ssh-options \"-p 22 -i /home/user/.ssh/key\"
  - Script will preserve hardlinks to remote system as long as using filesystem
    that supports hardlinks like ext4, btrfs, etc.
  - Recommended to use ssh key authentication for cron jobs using
    ~/.ssh/config file.
  - Need to be able to login to remote server as root when backing up /etc or
    other files a normal user does not have access to or will get errors.
  - Recommend modify remote server /etc/sshd_config with:
    PermitRootLogin without-password

SNAPSHOTS:
  - Can keep snapshots by amount and/or by days using either one or both of the
    below options.
  - Excessive amount or older days of snapshots will be deleted.
  - If no options are used then no snapshots will be deleted.
  - Deleting by days is based on folder timestamps and system time.
  - Recommend not using --snap-days when not sure if remote system (SSH) time
    or modification times are accurate.  Use --limit-amount instead.

WARNINGS:
  - Changing permissions on destination directories after a snapshot backup was
    performed can cause issues during next snapshot run since rsync is set
    to preserve owner and group permissions.
  - Use caution to what user is performing backup. Changing user after inital
    snapshots were created can cause issues.
  - Using --numeric-ids can help prevent the issues above.
  - Be careful when using --snap-amount and --snap-days together.
    Recommended to use one, but can use both if set properly.

--------------------------------------------------------------------------------
RESTORE:
  To restore files from backup, manually copy files from backup date/time
  destination directory to original or alternate location.

--------------------------------------------------------------------------------

"
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - perform rsync                                                   ║
# ╚════════════════════════════════════════════════════════════════════════════╝
perform_rsync() {
  # Create command based on if include file, directory or pull backup
  if [[ ${pull_backup} == "Y" ]]; then source=("${source[@]}""${pull_sources[@]}"); elif [[ -d "${source}" ]]; then source=("${source[@]}"); else source=(--files-from="${source[@]}" /); fi
  rsync_cmd=(rsync 
    "${rsync_options[@]}" 
    --log-file="${log_tmp}" 
    --exclude-from="${exclude_file}" 
    --exclude="${destination_dir}" 
    --link-dest="${destination_dir}"/"${current_link}"/ 
    "${sudo_command[@]}" 
    "${source[@]}"
    "${destination}"/"${backup_base}"@"${datetime}"/)

  msg "Performing rsync version backup to ${destination}\n"
  printf "  ---- ---- ---- ---- ---- Begin Rsync Log ---- ---- ---- ---- ----\n"
  "${rsync_cmd[@]}"
  return_code="$?"
  if [[ "${return_code}" == "23" ]]; then
    warn "(rsync code: ${return_code}) partial rsync transfer due to error for ${backup_base} to ${destination}"
  elif [[ "${return_code}" == "11" ]]; then
    err "(rsync code: ${return_code}) no such file or directory: ${destination}"
  elif [[ "${return_code}" -ne "0" ]]; then
    err "version backup during (rsync code: ${return_code}) for ${backup_base} to ${destination}"
  else
    suc "version backup for ${backup_base} to ${destination}"
  fi
  printf "  ---- ---- ---- ---- ---- End Rsync Log ---- ---- ---- ---- ----\n"
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - create softlink                                                 ║
# ╚════════════════════════════════════════════════════════════════════════════╝
create_softlink() {
  printf "\n"
  msg "Creating new softlink to latest version backup at ${destination}"
  if [[ "${use_ssh}" == "Y" ]]; then
    # SSH - Create soft link of current date-time to backup just created -- DO NOT QUOTE VARIABLES IN SSH
    if ! ssh "${ssh_options[@]}" "${ssh_server}" "rm -fv ${destination_dir}/${current_link} ; ln -sv ${destination_dir}/${backup_format} ${destination_dir}/${current_link}"; then
      err "creating SSH softlink on ${ssh_server} to ${destination}/${current_link}"
    fi
  else
    # Local - Create soft link of current date-time to backup just created
    rm -fv "${destination_dir}"/"${current_link}"
    if ! ln -sv "${destination_dir}"/"${backup_base}"@"${datetime}" "${destination}"/"${current_link}"; then
      err "creating LOCAL softlink to ${destination}/${current_link}"
    fi
  fi
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - remove old snapshot                                             ║
# ╚════════════════════════════════════════════════════════════════════════════╝
remove_old_snapshots() {
  if [[ ! -d "${destination_dir}/${backup_format}*" ]]; then
    # --- Keep snapshots by amount
    if [[ -n "${snapshot_amount}" ]]; then
      # Get number of backups in destination directory
      num_existing="$(find "${destination_dir}"/"${backup_base}"@* -maxdepth 0 -type d | wc -l)"
      # Remove snapshots amount if over snapshot limit
      if [[ "${num_existing}" -gt "${snapshot_amount}" ]]; then
        printf "\n"
        msg "Removing old snapshots by amount (Limit: ${snapshot_amount})"
        ((over="${num_existing}"-"${snapshot_amount}"))
        if ! find "${destination_dir}"/"${backup_base}"@* -maxdepth 0 -type d | head -n "${over}" | while read -r s; do rm -rf "${s}"; done
        then
          warn "Removing older snapshots (amount) from ${destination}"
        fi
      fi
    fi
    # --- Keep snapshots by days
    if [[ -n "${snapshot_amount_days}" ]]; then
      # List snapshot keep days if hit limit
      if [[ "$(find "${destination_dir}"/"${backup_base}"@* -mtime +"${snapshot_amount_days}" -print)" ]]; then
        printf "\n"
        msg "Removing old snapshots by days   (Limit: ${snapshot_amount_days})"
      fi
      if ! find "${destination_dir}"/"${backup_base}"@* -maxdepth 0 -type d -mtime +"${snapshot_amount_days}" -exec rm -rf {} \;
      then
        printf "\n"
        warn "Removing older snapshots (days) from ${destination}"
      fi
    fi
  else
    err "Destination directory not found at ${destination} -- Unable to remove old snapshots!"
  fi

  # List Snapshots
  printf "\n"
  msg "Listing backup snapshots at ${destination}"
  ls -d1 "${destination_dir}"/"${backup_base}"@*
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - remove old snapshots (ssh)                                      ║
# ╚════════════════════════════════════════════════════════════════════════════╝
ssh_remove_old_snapshots() {
  # Keep snapshots by amount -- DO NOT QUOTE VARIABLES IN SSH
  if [[ -n "${snapshot_amount}" ]]; then
    msg "Checking if snapshots need to be pruned to set limit"
    if ! ssh "${ssh_options[@]}" "${ssh_server}" "
    if [[ -n ${snapshot_amount} ]]; then
      # Create variable count of backups in directory at destination
      num_existing=\$(find ${destination_dir}/${backup_base}@* -maxdepth 0 -type d |wc -l)
      # Remove snapshots amount if over snapshot limit
      if [[ \${num_existing} -gt ${snapshot_amount} ]]; then
        echo "[${program_title}] Removing old snapshots by amount - Limit: ${snapshot_amount}"
        let over=${num_existing}-${snapshot_amount}
        if ! find ${destination_dir}/${backup_base}@* -maxdepth 0 -type d | head -n \${over} | while read s; do rm -rf \${s}; done
        then
          echo "Removing older snapshots amount from ${destination}"
        fi
        # List Snapshots
        echo "[${program_title}] Listing backup snapshots at ${destination}"
        ls -d1 ${destination_dir}/${backup_base}@*
      fi
    fi
    "
    then
      warn "SSH removing older amount snapshots from ${destination}"
    fi
  fi
  # Keep snapshots by days
  if [[ -n "${snapshot_amount_days}" ]]; then
    msg "SSH Removing old snapshots from ${destination_dir} if days reached (Limit: ${snapshot_amount_days})"
    if ! ssh "${ssh_options[@]}" "${ssh_server}" "find ${destination_dir}/${backup_base}@* -maxdepth 0 -type d -mtime +${snapshot_amount_days} -exec rm -rf {} \;"
    then
      warn "SSH removing older days snapshots from ${destination}/${current_link}"
    fi
  fi
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - rsync (dryrun)                                                  ║
# ╚════════════════════════════════════════════════════════════════════════════╝
rsync_dryrun() {
  printf "\n-----------------------------------------------------------------------------------------------"
  printf "%s\n[${program_title}] Performing dry-run of rsync for testing - Actual backup will NOT be performed"
  printf "\n-----------------------------------------------------------------------------------------------\n"
  rsync_options+=( --dry-run)
  perform_rsync
  printf "\n-----------------------------------------------------------------------------------------------"
  printf "%s\n[${program_title}] Finished performing dry-run of rsync for testing - Actual backup was NOT performed"
  printf "\n-----------------------------------------------------------------------------------------------\n\n"
  exit 0
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - send functions                                                  ║
# ╚════════════════════════════════════════════════════════════════════════════╝

send_mail() {
  msg "Sending mail to ${mail_address}"
  if ! mail -s "${log_subject[*]}" "${mail_address}" < "${log_tmp}"
  then
    warn "Issue when sending mail"
  fi
}

send_syslog() {
  msg "Sending message to syslog"
  if ! logger -s -t rsyncsnap "${log_subject[0]} ${log_subject[2]}" > /dev/null 2>&1
  then
    warn "Issue when sending message via logger"
  fi
}

send_remove_old_logs() {
  msg "Searching for logs to remove over ${log_limit_days} days old in ${ldir}:"
  find "${ldir}"/"${backup_base}"-*.log -maxdepth 1 -mtime +"${log_limit_days}" -exec rm -vf {} \;
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - create logfile                                                  ║
# ╚════════════════════════════════════════════════════════════════════════════╝
create_logfile() {
  ## Create log file option
  if [[ -n "${lfile}" ]]; then msg "Appending log to: ${logfile_location}"; fi
  if [[ -n "${ldir}" ]]; then msg "Created log: ${logfile_location}"; fi
  cat "${log_tmp}" >> "${logfile_location}" || err "Creating log in: ${logfile_location}"
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - cleanup                                                         ║
# ╚════════════════════════════════════════════════════════════════════════════╝
cleanup() {
  # Cleanup temp logfile
  rm -f "${log_tmp}"
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - trap exit                                                       ║
# ╚════════════════════════════════════════════════════════════════════════════╝
trap_exit() {
  # Set mail subject
  err "Ended forceably and trapped"
  error_warn="Y"
  # Create logfile if enabled
  create_logfile
  # Send mail if enabled
  send_mail
  # Cleanup ${log_tmp}
  cleanup
  exit 1
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - log errors                                                      ║
# ╚════════════════════════════════════════════════════════════════════════════╝
log_errors() {
  error_warn="Y"
  printf "  ---- ---- ---- ---- ---- End Rsync Log ---- ---- ---- ---- ----\n"

  printf -- "\n-----------------------------------------------------------------------------------------------\n"
  printf "%s${log_subject[*]}\n"
  printf -- "-----------------------------------------------------------------------------------------------\n"

  if [[ "${sendmail}" == "Y" ]]; then send_mail; fi
  if [[ -n "${lfile}" ]] || [[ -n "${ldir}" ]]; then create_logfile; fi
  printf "%s\n[${program_title}] (END) -- $(printf '%(%A %Y-%m-%d %H:%M:%S)T' -1)"
  printf "\n===============================================================================================\n"
  #cleanup
  exit 1
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - helpmsg                                                         ║
# ╚════════════════════════════════════════════════════════════════════════════╝
helpmsg() {
  helpformat[0]="[${program_title}]"
  helpformat[1]="$1"
  helpformat[2]="$2"
  printf "%s\n${helpformat[0]}\n  Usage: $0 ${helpformat[1]}\n         $0 ${helpformat[2]}\n\n"
  exit 0
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - run backup                                                      ║
# ╚════════════════════════════════════════════════════════════════════════════╝
run_backup() {
  start=$(date +%s)
  # Log header start
  printf "\n===============================================================================================\n"
  printf "%s[${program_title}] (START) -- $(printf '%(%A %Y-%m-%d %H:%M:%S)T' -1)\n"
  if [[ "${pull_backup}" == "Y" ]]; then msg "Pulling backup from ${source[@]} to ${destination}"; else msg "Pushing backup from ${source[@]} to ${destination}"; fi

  # Run main rsync function
  perform_rsync
  
  # Run create softlink function if no errors during rsync
  if [[ ${error_warn} != "Y" ]]; then create_softlink; fi

  # Perform other tasks (local or ssh)
  if [[ "${use_ssh}" == "Y" ]] || [[ "${destination_dir}" = *:* ]]; then
    ## If SSH
    ssh_remove_old_snapshots
    #list_snapshots
  else
    ## If LOCAL
    remove_old_snapshots
    #list_snapshots
  fi
  finish=$(date +%s)

  ## Print log status to terminal
  printf -- "\n-----------------------------------------------------------------------------------------------\n"
  printf "%s${log_subject[*]}\n"
  printf -- "-----------------------------------------------------------------------------------------------\n"
  
  printf "%sTotal time: $(( ($finish-$start) / 60 )) minutes, $(( ($finish-$start) % 60 )) seconds\n\n"

  if [[ "${pull_backup}" == "Y" ]]; then msg "Performed pull backup from ${source[@]} to ${destination}"; fi
  if [[ "${use_sudo}" == "Y" ]]; then msg "Used (sudo) during rsync as user: ${sudo_user}"; fi

  if [[ "${sendmail}" == "Y" ]]; then send_mail; fi
  if [[ "${sendsyslog}" == "Y" ]]; then send_syslog; fi

  # Show if using --log-file
  if [[ -n "${lfile}" ]]; then create_logfile; fi

  # Log header end
  printf "%s[${program_title}] (END) -- $(printf '%(%A %Y-%m-%d %H:%M:%S)T' -1)"
  printf "\n===============================================================================================\n"
}

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ function - main                                                            ║
# ╚════════════════════════════════════════════════════════════════════════════╝
main() {
  # ╔════════════════════════════════════════════════════════════════════════════╗
  # ║ CASE OPTIONS                                                               ║
  # ╚════════════════════════════════════════════════════════════════════════════╝
  # Multiple Argument Selection
  while [[ "$#" -gt 0 ]]
  do  
  option="$1"
  case "$option" in
  # OPTIONS ---------------------------------------------------------
    -e|--exclude|--excludes)
      exclude_file="${2%/}" # Remove trailing slashes
      shift
      if [[ ! -f "${exclude_file}" ]] || [[ "${exclude_file}" == -* ]]; then helpmsg "ERROR Exclude list file not found!" "Type $0 --help for usage"; fi
    ;;
    --snap-amount)
      snapshot_amount="$2"
      shift
      if [[ -z "${snapshot_amount}" ]] || [[ "${snapshot_amount}" == -* ]]; then helpmsg "--snap-amount <number>" "--snap-amount 15"; fi
    ;;
    --snap-days)
      snapshot_amount_days="$2"
      shift
      if [[ -z "${snapshot_amount_days}" ]] || [[ "${snapshot_amount_days}" == -* ]]; then helpmsg "--snap-days <number>" "--snap-days 30"; fi
    ;;
    --rsync-options)
      rsync_options=( "$2")
      shift
    ;;
    --numeric-ids)
      rsync_options+=( --numeric-ids)
      shift
    ;;
    --ssh)
      use_ssh="Y"
    ;;
    --ssh-options)
      extra_ssh_options=( "$2")
      # do not quote ssh_options variable
      ssh_options+=( ${extra_ssh_options[@]})
      rsync_options+=( -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null ${extra_ssh_options[@]}")
      shift
    ;;
    --sudo)
      sudo_user="$2"
      sudo_command=(--rsync-path="sudo ${sudo_user}")
      use_sudo="Y"
      if [[ -z "${sudo_user}" ]] || [[ "${sudo_user}" == -* ]]; then helpmsg "--sudo <username>" "--sudo rsync"; fi
      shift
    ;;
    --pull)
      pull_sources=($2)
      pull_backup="Y"
      use_ssh="N"
      if [[ -z "${pull_sources}" ]] || [[ "${pull_sources}" == -* ]]; then
        helpmsg "--pull <sources>" "--pull \":/etc/ :/home/ :/usr/local/\""
        printf "NOTICE: Use \"quotes\"\nNOTICE: Use : before directories \":/etc/ :/home/ :/var/\" \n\n"
        exit 0
      fi
      if [[ "${source}" = *:* ]] || [[ "${use_ssh}" == "Y" ]]; then
        helpmsg "When using --pull it must NOT be used with a folder destination (user@server:/destination)" "--pull"
      fi
      shift
    ;;
  # SEND MESSAGES ----------------------------------------------------
    --logfile|--log)
      lfile="$2"
      shift
      if [[ -z "${lfile}" ]] || [[ "${lfile}" == -* ]]; then
        helpmsg "--logfile </path/to/file.log>" "--logfile /var/log/mybackup.log"
      fi
      logfile_location="${lfile}"
      msg "-- $(printf '%(%A %Y-%m-%d %H:%M:%S)T' -1)" >> "${logfile_location}"
    ;;
    --mail|--email)
      mail_address="$2"
      shift
      if [[ -z "${mail_address}" ]] || [[ "${mail_address}" == -* ]]; then
        helpmsg "--mail <email_address>" "--mail user@domain"
      fi
      sendmail="Y"
    ;;
    --syslog)
      sendsyslog="Y"
    ;;
  # TESTING ---------------------------------------------------
    --test|--dry-run)
      rsync_dryrun
    ;;
    --debug)
      set -x
    ;;
  # ------------------------------------------------------------
    -h|--help)
      usage
      exit 0
    ;;
  # ------------------------------------------------------------
    -*)
      err "Unknown Option: '${option}' -- Type '$0 --help' for usage information"
      exit 0
    ;;
  esac
  shift
  done

  # ╔════════════════════════════════════════════════════════════════════════════╗
  # ║ ERROR CHECKING INPUT                                                       ║
  # ╚════════════════════════════════════════════════════════════════════════════╝
  if [[ -z "${source}" ]]; then printf "%s\nSource or include file list not entered!  Type $0 --help  for usage\n\n"; exit 1; fi
  if [[ -z "${destination_dir}" ]]; then printf "%s\nBackup destination not entered!  Type $0 --help  for usage\n\n"; exit 1; fi

  # ╔════════════════════════════════════════════════════════════════════════════╗
  # ║ TRAP                                                                       ║
  # ╚════════════════════════════════════════════════════════════════════════════╝
  trap trap_exit 2

  # ╔════════════════════════════════════════════════════════════════════════════╗
  # ║ RUN ENTIRE BACKUP PROCESS WITH LOGGING                                     ║
  # ╚════════════════════════════════════════════════════════════════════════════╝
  run_backup 2>&1 | tee -a "${log_tmp}"

  # ╔════════════════════════════════════════════════════════════════════════════╗
  # ║ cleanup for end of script                                                  ║
  # ╚════════════════════════════════════════════════════════════════════════════╝
  cleanup
  printf "\n"
}

main "$@"

# ╔════════════════════════════════════════════════════════════════════════════╗
# ║ END                                                                        ║
# ╚════════════════════════════════════════════════════════════════════════════╝
