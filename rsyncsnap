#!/bin/bash
### rsyncsnap -- Rsync Incremental Backups Using Bash
### Ken Bernier 2019
###
### https://github.com/nicedreams/rsyncsnap
#
# This script is free software. You can redistribute it and/or modify it under the terms of the GNU
# General Public License Version 3 (or at your option any later version) as published by The Free
# Software Foundation.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# See the GNU General Public License for more details.
# If you did not received a copy of the GNU General Public License along with this script see
# http://www.gnu.org/copyleft/gpl.html or write to The Free Software Foundation, 675 Mass Ave,
# Cambridge, MA 02139, USA.
#
###

##########################################
### VARIABLES
##########################################
### Add extra rsync options [example: --dry-run]
# Do Not Use --delete / Will cause consistency issues with incremental snapshots.
# Removing -r  causes rsync not to transfer sub directories even though -a is used.
# Add --dry-run for testing (-arSvh --dryrun).
rsync_options=(-arSvh)
### Add extra ssh options
# Remove -q to have SSH verbose output.
ssh_options=(-n -q)
### Date_Time formatting (Formatted to work with Samba & Windows Previous Verions)
date_time="$(date +GMT-%Y.%m.%d-%H.%M.%S)"
log_date_time="$(date "+%A %Y-%m-%d %H:%M:%S")"
### Temp log location
log_tmp="/tmp/rsyncsnap.log.tmp"
# Location of rsyncsnap.include and rsyncsnap.exclude files (remove trailing slash variable)
backup_include_file="${1%/}"
### Destination directory to store backups (remove trailing slash from variable)
backup_dest_dir="${2%/}"
backup_dest_dir_ssh="${backup_dest_dir%:*}"
backup_dest_dir_path="${backup_dest_dir#*:}"
### Name the destination backup archive based on rsyncsnap.include filename
pre_backup_base="${backup_include_file##*/}"
backup_base="${pre_backup_base%.*}"
### How many snapshots to keep
keep_snapshots="$3"
keep="$((keep_snapshots+1))"
###
last_backup="$backup_base-current"
#############################################

usage() {
echo "
========================================================================
rsyncsnap

https://github.com/nicedreams/rsyncsnap

Uses rsync to create incremental snapshots with hard links.
Only changed files use disk space.

Add directories to backup in rsyncsnap.include file (mandatory)
Add directories to exclude in rsyncsnap.exclude file (optional)
Use include/exclude examples from git repo README if needed.

Name of backup is set using first part of filename.  Can name include
file anything you want and extension is not required.

USAGE:
  rsyncsnap <include_file> <destination> <snapshots> <options>

  rsyncsnap /root/rsyncsnap.include /mnt/backups/rsyncsnap 15 \\
            --exclude /root/rsyncsnap.exclude \\
            --logfile /var/log/rsyncsnap.log \\
            --email user@domain \\
            --syslog

  rsyncsnap /root/rsyncsnap.include \\
            user@domain:/home/user/backups/rsyncsnap 15 \\
            --exclude /root/rsyncsnap.exclude \\
            --logfile /var/log/rsyncsnap-remote.log

  <include_file>  Full path and filename of rsyncsnap.include file
  <destination>   Where to store backups: /mnt/backups/rsyncsnap
  <snapshots>     Amount of snapshots to keep: 15

CAUTION:        If snapshot amount is set to 1, all snapshots will be
                removed and be left with a single backup.

SSH NOTICE:     - Script will preserve hardlinks to remote system as
                  long as using filesystem that supports hardlinks
                  like ext4.
                - Recommended to use ssh key authentication for cron
                  jobs using ~/.ssh/config file.
                - Need to be able to login to remote server as root
                  when backing up /etc and other system files.
                  Recommend modify remote server /etc/sshd_config with:
                    PermitRootLogin without-password
                  to allow root login only with ssh keys.

OPTIONS:
  -e | --exclude  Path of exclude file: /home/user/rsyncsnap.exclude

  -l | --logfile  Path of logfile: /var/log/rsyncsnap.log

  --syslog        Send SUCCESS/ERROR message to syslog using logger

  --email         Send email (mail command)
                  --email user@domain.com  OR  --email root

  --datetime      Default: GMT-%Y.%m.%d-%H.%M.%S
                  Change date/time formatting of backup directory
                  Uses linux date command formatting
                  --datetime %m.%d.%Y-%H.%M

  --test          Perform rsync version backup using --dry-run to test
                  backup.  No actual backup will be performed.
                  Use without -l, --syslog or --email options.

Single Run Options:
  -du | --size    Get accurate size of entire backup destination (du)
                  --size /mnt/backups/rsyncsnap/

  --hardlinks     Check inode hardlink info of file in backup
                  --hardlinks <backup_destination> <filename_to_check>
                  --hardlinks /mnt/backups/rsyncsnap filename.ext

  --help          Print this usage information

RESTORE:
  To restore files from backup, manually copy files from backup
  date/time destination directory to original or alternate location.
========================================================================
"
}

perform_rsync() {
  printf "\n[rsyncsnap] Performing rsync version backup\n"
  printf "  ---- ---- ---- Begin Rsync Log ---- ---- ---- ---- \n"
  if ! rsync "${rsync_options[@]}" \
    --log-file="$log_tmp" \
    --files-from="$backup_include_file" \
    --exclude-from="$backup_exclude_file" \
    --exclude="$backup_dest_dir_path" \
    --link-dest="$backup_dest_dir_path"/"$last_backup"/ \
    "/" \
    "$backup_dest_dir"/"$backup_base"@"$date_time"/
  then
    log_subject="[ERROR] (rsyncsnap) rsync version backup for $backup_base at $backup_dest_dir!"
    exit_error
  else
    log_subject="[SUCCESS] (rsyncsnap) rsync version backup for $backup_base at $backup_dest_dir"
    printf "  ---- ---- ---- End Rsync Log ---- ---- ---- ---- \n"
  fi
}

create_softlink() {
  printf "\n%s[rsyncsnap] Creating new softlink to latest version backup at $backup_dest_dir\n"
  if [[ "$backup_dest_dir" = *:* ]]; then
    ### SSH - Create soft link of current date-time to backup just created
    if ! ssh "${ssh_options[@]}" "$backup_dest_dir_ssh" "rm -fv $backup_dest_dir_path/$last_backup ; ln -sv $backup_dest_dir_path/$backup_base@$date_time $backup_dest_dir_path/$last_backup"
    then
      log_subject="[ERROR] (rsyncsnap) creating SSH softlink $backup_dest_dir_path/$last_backup"
      exit_error
    fi
  else
    ### Local - Create soft link of current date-time to backup just created
    rm -fv "$backup_dest_dir_path"/"$last_backup"
    ln -sv "$backup_dest_dir_path"/"$backup_base"@"$date_time" "$backup_dest_dir_path"/"$last_backup"
  fi
}

remove_old_snapshots() {
  if [[ ! -d "$backup_dest_dir_path/$backup_base@*" ]]; then
    ### Create variable of snapshot count in destination
    active_snapshots="$(find "$backup_dest_dir_path"/"$backup_base"@* -maxdepth 0 -type d |wc -l)"

    ### List snapshot keep count if hit limit
    if [[ "$active_snapshots" -ge "$keep_snapshots" ]]; then
      printf "\n%s[rsyncsnap] Removing old snapshots (Limit: $keep_snapshots)\n"
    fi

    ### Remove backup snapshot directories over keep limit ### Give error if issues removing snapshot directory
    if ! find "$backup_dest_dir_path"/"$backup_base"@* -maxdepth 0 -type d |sort -r |tail -n +"$keep" | while read -r fname; do rm -rf "$fname"; done
    then
      printf "\n%s[rsyncsnap] ERROR Removing older snapshots from $backup_dest_dir\n"
    fi
  else
    printf "\n%s[rsyncsnap] ERROR Destination directory not found at $backup_dest_dir\n"
    printf "\n[rsyncsnap] ERROR Unable to remove old snapshots!\n"
  fi
}

ssh_remove_old_snapshots() {
  ### Remove old snapshots from remote ssh directory if limit is reached
  printf "\n%s[rsyncsnap] SSH Removing old snapshots from $backup_dest_dir if reached (Limit: $keep_snapshots)\n"
  if ! ssh "${ssh_options[@]}" "$backup_dest_dir_ssh" "find $backup_dest_dir_path/$backup_base@* -maxdepth 0 -type d |sort -r |tail -n +$keep | while read -r fname; do rm -rf \$fname; done"
  then
    log_subject="[ERROR] (rsyncsnap) SSH removing older snapshots from $backup_dest_dir_path/$last_backup"
    exit 1
  fi
}

list_snapshots() {
  printf "\n%s[rsyncsnap] Listing backup snapshots at $backup_dest_dir\n"
  if [[ "$backup_dest_dir" = *:* ]]; then
    ssh "${ssh_options[@]}" "$backup_dest_dir_ssh" "ls -d1 $backup_dest_dir_path/$backup_base@*"
  else
    ls -d1 "$backup_dest_dir_path"/"$backup_base"@*
  fi
}

test_vars() {
  ### TEST VARIABLES  #########################################################
  printf "\n%s date_time: \t $date_time"
  printf "\n%s rsync_options: \t ${rsync_options[*]}"
  printf "\n%s ssh_options: \t ${ssh_options[*]}"
  printf "\n%s log_tmp: \t $log_tmp"
  printf "\n%s backup_include_file: \t $backup_include_file"
  printf "\n%s backup_dest_dir: \t $backup_dest_dir"
  printf "\n%s backup_dest_dir_ssh: \t $backup_dest_dir_ssh"
  printf "\n%s backup_dest_dir_path: \t $backup_dest_dir_path"
  printf "\n%s pre_backup_base: \t $pre_backup_base"
  printf "\n%s backup_base: \t $backup_base"
  printf "\n%s keep_snapshots: \t $keep_snapshots"
  printf "\n%s keep: \t $keep"
  printf "\n%s last_backup: \t $last_backup"
  printf "\n%s backup_dest_dir/backup_base@date_time: \t $backup_dest_dir/$backup_base@$date_time"
  printf "\n%s backup_exclude: \t $backup_exclude_file"
  printf "\n%s logfile_location: \t $logfile_location"
  printf "\n%s email_address: \t $email_address"
  printf "\n%s log_subject: \t\t $log_subject"
  printf "\n%s log_tmp: \t\t\t $log_tmp \n\n"
  ### TEST VARIABLES  #########################################################
  exit 0
}

list_hardlinks() {
  if [[ -z "$set_hardlink_dest" ]] || [[ -z "$hardlink_filename" ]]
  then
    printf "\n[rsyncsnap] Usage: rsyncsnap --hardlinks <backup_destination> <filename>\n[rsyncsnap]        rsyncsnap /ext/backup myfile.txt\n\n"
  else
    printf "\n[rsyncsnap] If no file results shown, then file is not found"
    printf "\n%s[rsyncsnap] Showing inode (hardlinks) for \"$hardlink_filename\" in \"$set_hardlink_dest\""
    printf "\n%s$(find "$set_hardlink_dest" -name "$hardlink_filename" -ls)\n\n"
  fi
  exit 0
}

backup_size() {
  if [[ -z "$set_backup_size" ]]
  then
    printf "\n[rsyncsnap] Usage: rsyncsnap --size <backup_destination>\n[rsyncsnap]        rsyncsnap /ext/backup\n\n"
  else
    printf "\n%s[rsyncsnap] Using du command to show accurate full size of \"$set_backup_size\""
    printf "\n%s  $(du -sh "$set_backup_size")\n\n"
  fi
  exit 0
}

rsync_dryrun() {
  printf "\n[rsyncsnap] Performing dry-run of rsync for testing - Actual backup will NOT be performed\n\n"
  rsync_options+=( --dry-run)
  perform_rsync
  printf "\n[rsyncsnap] Finished performing dry-run of rsync for testing - Actual backup was NOT performed\n\n"
  exit 0
}

format_log() {
  # Start log header
  printf "\n--------------------------------------------------------"
  printf "\n%s RSYNCSNAP STARTED -- $log_date_time"
  printf "\n--------------------------------------------------------\n"
}

create_logfile() {
  ## Create log file option
  if [[ "$set_send_logfile" == "Y"  ]]; then
    #printf "\n%s[rsyncsnap] Creating log in: $logfile_location\n"
    cat "$log_tmp" >> "$logfile_location"
  fi
}

exit_error() {
  ## Log if error and exit
  create_logfile
  printf "\n%s\n\n" "$log_subject"
  exit 1
}

###############################################
### RUN SCRIPT
###############################################

### Multiple Argument Selection
while [[ "$#" -gt 0 ]]
do
key="$1"
case "$key" in
  -e|--exclude)
    backup_exclude_file="${2%/}" # Remove trailing slashes
    shift
    if [[ ! -f "$backup_exclude_file" ]]; then
      printf "\n%s[rsyncsnap] ERROR Exclude list file not found!\n [rsyncsnap] Type $0 --help for usage\n\n"
      exit 0
    fi
  ;;
  -l|--logfile|--log)
    logfile_location="${2%/}" # Remove tailing slashes
    shift
    if [[ -z "$logfile_location" ]]
    then
      printf "\n[rsyncsnap] Usage: rsyncsnap --logfile <logfile_location>\n[rsyncsnap]        rsyncsnap --logfile /var/log/rsnapsync.log\n\n"
      exit 0
    fi
    set_send_logfile="Y"
  ;;
  --syslog)
    set_send_syslog="Y"
  ;;
  --email)
    email_address="$2"
    shift
    if [[ -z "$email_address" ]]; then
      printf "\n[rsyncsnap] Usage: rsyncsnap --email <email_address>\n[rsyncsnap]        rsyncsnap --email user@domain\n\n"
      exit 0
    fi
    set_send_email="Y"
  ;;
  --datetime)
    date_time="$(date +"$2")"
    shift
  ;;
  --test | --dry-run)
    rsync_dryrun
  ;;
  -du|--size)
    set_backup_size="$2"
    shift
    backup_size
  ;;
  --hardlink|--hardlinks)
    set_hardlink_dest="$2"
    hardlink_filename="$3"
    shift
    shift
    list_hardlinks
  ;;
  --debug)
    test_vars
  ;;
  -h|--help)
    usage
    exit 0
  ;;
  *)
  ;;
esac
shift
done

### ERROR CHECKING INPUT
if [[ -z "$backup_include_file" ]]; then printf "\n%s[rsyncsnap] ERROR Include list file not entered!\n\n[rsyncsnap] Type $0 --help  for usage\n\n"; exit 1; fi
if [[ ! -f "$backup_include_file" ]]; then printf "\n%s[rsyncsnap] ERROR Include list file not found!\n[rsyncsnap] Type $0 --help  for usage\n\n"; exit 1; fi
if [[ -z "$backup_dest_dir" ]]; then printf "\n%s[rsyncsnap] ERROR Backup destination not entered!\n\n[rsyncsnap] Type $0 --help  for usage\n\n"; exit 1; fi
if [[ "$keep_snapshots" =~ ^[0-9]+$ ]]; then echo; else printf "\n%s[rsyncsnap] ERROR Snapshot amount not entered and must be a number\n[rsyncsnap] Type $0 --help  for usage\n\n"; exit 1; fi
#if [[ ! -d "$backup_dest_dir" ]]; then printf "\n%s[rsyncsnap] ERROR $backup_dest_dir NOT FOUND OR NO PERMISSIONS TO DIRECTORY - Exiting!\n[rsyncsnap] Type $0 --help  for usage\n\n"; exit 1; fi

### TRAP Exit for clean up
trap 'rm -f $log_tmp' EXIT

### START RUN SCRIPT WITH LOGGING ###
{
  ### Start log formatting
  format_log

  ### Run main rsync function
  perform_rsync
  # Run create softlink function
  create_softlink

  ### Perform other tasks (local or ssh)
  if [[ "$backup_dest_dir" = *:* ]]; then
    ## If SSH
    ssh_remove_old_snapshots
    list_snapshots
  else
    ## If LOCAL
    remove_old_snapshots
    list_snapshots
  fi

  ## Send message to syslog option
  if [[ "$set_send_syslog" == "Y"  ]]; then
    printf "\n[rsyncsnap] Sending message to Syslog\n"
    if ! logger -s -t rsyncsnap "$log_subject" > /dev/null 2>&1
    then
      printf "\n[rsyncsnap] ERROR Sending message to syslog\n"
    fi
  fi

  ## Send email log option
  if [[ "$set_send_email" == "Y"  ]]; then
    printf "\n%s[rsyncsnap] Sending email log to $email_address\n"
    if ! mail -s "$log_subject" "$email_address" < "$log_tmp"
    then
      printf "%s[rsyncsnap] ERROR Sending email to $email_address\n"
    fi
  fi

  ## Print log status to terminal
  printf "\n%s\n\n" "$log_subject"

} 2>&1 | tee -a "$log_tmp"
### END RUN SCRIPT WITH LOGGING ###

### Leave as last line
create_logfile

### Cleanup $log_tmp
rm -f "$log_tmp"

### END
exit 0
